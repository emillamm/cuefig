// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/argoproj/argo-rollouts/pkg/apis/rollouts/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	intstrutil "k8s.io/apimachinery/pkg/util/intstr"
	batchv1 "k8s.io/api/batch/v1"
)

// ClusterAnalysisTemplate holds the template for performing canary analysis
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=clusteranalysistemplates,shortName=cat,scope=Cluster
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
#ClusterAnalysisTemplate: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta    @go(ObjectMeta) @protobuf(1,bytes,opt)
	spec:      #AnalysisTemplateSpec @go(Spec) @protobuf(2,bytes,opt)
}

// AnalysisTemplateList is a list of AnalysisTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#ClusterAnalysisTemplateList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items: [...#ClusterAnalysisTemplate] @go(Items,[]ClusterAnalysisTemplate) @protobuf(2,bytes,rep)
}

// AnalysisTemplate holds the template for performing canary analysis
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=analysistemplates,shortName=at
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
#AnalysisTemplate: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta    @go(ObjectMeta) @protobuf(1,bytes,opt)
	spec:      #AnalysisTemplateSpec @go(Spec) @protobuf(2,bytes,opt)
}

// AnalysisTemplateList is a list of AnalysisTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#AnalysisTemplateList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items: [...#AnalysisTemplate] @go(Items,[]AnalysisTemplate) @protobuf(2,bytes,rep)
}

// AnalysisTemplateSpec is the specification for a AnalysisTemplate resource
#AnalysisTemplateSpec: {
	// Metrics contains the list of metrics to query as part of an analysis run
	// +patchMergeKey=name
	// +patchStrategy=merge
	metrics?: [...#Metric] @go(Metrics,[]Metric) @protobuf(1,bytes,rep)

	// Args are the list of arguments to the template
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +optional
	args?: [...#Argument] @go(Args,[]Argument) @protobuf(2,bytes,rep)

	// DryRun object contains the settings for running the analysis in Dry-Run mode
	// +patchMergeKey=metricName
	// +patchStrategy=merge
	// +optional
	dryRun?: [...#DryRun] @go(DryRun,[]DryRun) @protobuf(3,bytes,rep)

	// MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
	// +patchMergeKey=metricName
	// +patchStrategy=merge
	// +optional
	measurementRetention?: [...#MeasurementRetention] @go(MeasurementRetention,[]MeasurementRetention) @protobuf(4,bytes,rep)

	// Templates reference to a list of analysis templates to combine with the rest of the metrics for an AnalysisRun
	// +patchMergeKey=templateName
	// +patchStrategy=merge
	templates?: [...#AnalysisTemplateRef] @go(Templates,[]AnalysisTemplateRef) @protobuf(5,bytes,rep)
}

// DurationString is a string representing a duration (e.g. 30s, 5m, 1h)
#DurationString: string

// Metric defines a metric in which to perform analysis
#Metric: {
	// Name is the name of the metric
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Interval defines an interval string (e.g. 30s, 5m, 1h) between each measurement.
	// If omitted, will perform a single measurement
	interval?: #DurationString @go(Interval) @protobuf(2,bytes,opt,casttype=DurationString)

	// InitialDelay how long the AnalysisRun should wait before starting this metric
	initialDelay?: #DurationString @go(InitialDelay) @protobuf(3,bytes,opt,casttype=DurationString)

	// Count is the number of times to run the measurement. If both interval and count are omitted,
	// the effective count is 1. If only interval is specified, metric runs indefinitely.
	// If count > 1, interval must be specified.
	count?: null | intstrutil.#IntOrString @go(Count,*intstrutil.IntOrString) @protobuf(4,bytes,opt)

	// SuccessCondition is an expression which determines if a measurement is considered successful
	// Expression is a goevaluate expression. The keyword `result` is a variable reference to the
	// value of measurement. Results can be both structured data or primitive.
	// Examples:
	//   result > 10
	//   (result.requests_made * result.requests_succeeded / 100) >= 90
	successCondition?: string @go(SuccessCondition) @protobuf(5,bytes,opt)

	// FailureCondition is an expression which determines if a measurement is considered failed
	// If both success and failure conditions are specified, and the measurement does not fall into
	// either condition, the measurement is considered Inconclusive
	failureCondition?: string @go(FailureCondition) @protobuf(6,bytes,opt)

	// FailureLimit is the maximum number of times the measurement is allowed to fail, before the
	// entire metric is considered Failed (default: 0)
	// -1 for making it disabled (when opting to use ConsecutiveSuccessLimit solely)
	failureLimit?: null | intstrutil.#IntOrString @go(FailureLimit,*intstrutil.IntOrString) @protobuf(7,bytes,opt)

	// InconclusiveLimit is the maximum number of times the measurement is allowed to measure
	// Inconclusive, before the entire metric is considered Inconclusive (default: 0)
	inconclusiveLimit?: null | intstrutil.#IntOrString @go(InconclusiveLimit,*intstrutil.IntOrString) @protobuf(8,bytes,opt)

	// ConsecutiveErrorLimit is the maximum number of times the measurement is allowed to error in
	// succession, before the metric is considered error (default: 4)
	consecutiveErrorLimit?: null | intstrutil.#IntOrString @go(ConsecutiveErrorLimit,*intstrutil.IntOrString) @protobuf(9,bytes,opt)

	// Provider configuration to the external system to use to verify the analysis
	provider: #MetricProvider @go(Provider) @protobuf(10,bytes,opt)

	// ConsecutiveSuccessLimit is the number of consecutive times the measurement must succeed for the
	// entire metric to be considered Successful (default: 0, which means it's disabled)
	consecutiveSuccessLimit?: null | intstrutil.#IntOrString @go(ConsecutiveSuccessLimit,*intstrutil.IntOrString) @protobuf(11,bytes,opt)
}

// DryRun defines the settings for running the analysis in Dry-Run mode.
#DryRun: {
	// Name of the metric which needs to be evaluated in the Dry-Run mode. Wildcard '*' is supported and denotes all
	// the available metrics.
	metricName: string @go(MetricName) @protobuf(1,bytes,opt)
}

// MeasurementRetention defines the settings for retaining the number of measurements during the analysis.
#MeasurementRetention: {
	// MetricName is the name of the metric on which this retention policy should be applied.
	metricName: string @go(MetricName) @protobuf(1,bytes,opt)

	// Limit is the maximum number of measurements to be retained for this given metric.
	limit: int32 @go(Limit) @protobuf(2,varint,opt)
}

// TTLStrategy defines the strategy for the time to live depending on if the analysis succeeded or failed
#TTLStrategy: {
	// SecondsAfterCompletion is the number of seconds to live after completion.
	secondsAfterCompletion?: null | int32 @go(SecondsAfterCompletion,*int32) @protobuf(1,varint,opt)

	// SecondsAfterFailure is the number of seconds to live after failure.
	secondsAfterFailure?: null | int32 @go(SecondsAfterFailure,*int32) @protobuf(2,varint,opt)

	// SecondsAfterSuccess is the number of seconds to live after success.
	secondsAfterSuccess?: null | int32 @go(SecondsAfterSuccess,*int32) @protobuf(3,varint,opt)
}

// MetricProvider which external system to use to verify the analysis
// Only one of the fields in this struct should be non-nil
#MetricProvider: {
	// Prometheus specifies the prometheus metric to query
	prometheus?: null | #PrometheusMetric @go(Prometheus,*PrometheusMetric) @protobuf(1,bytes,opt)

	// Kayenta specifies a Kayenta metric
	kayenta?: null | #KayentaMetric @go(Kayenta,*KayentaMetric) @protobuf(2,bytes,opt)

	// Web specifies a generic HTTP web metric
	web?: null | #WebMetric @go(Web,*WebMetric) @protobuf(3,bytes,opt)

	// Datadog specifies a datadog metric to query
	datadog?: null | #DatadogMetric @go(Datadog,*DatadogMetric) @protobuf(4,bytes,opt)

	// Wavefront specifies the wavefront metric to query
	wavefront?: null | #WavefrontMetric @go(Wavefront,*WavefrontMetric) @protobuf(5,bytes,opt)

	// NewRelic specifies the newrelic metric to query
	newRelic?: null | #NewRelicMetric @go(NewRelic,*NewRelicMetric) @protobuf(6,bytes,opt)

	// Job specifies the job metric run
	job?: null | #JobMetric @go(Job,*JobMetric) @protobuf(7,bytes,opt)

	// CloudWatch specifies the cloudWatch metric to query
	cloudWatch?: null | #CloudWatchMetric @go(CloudWatch,*CloudWatchMetric) @protobuf(8,bytes,opt)

	// Graphite specifies the Graphite metric to query
	graphite?: null | #GraphiteMetric @go(Graphite,*GraphiteMetric) @protobuf(9,bytes,opt)

	// Influxdb specifies the influxdb metric to query
	influxdb?: null | #InfluxdbMetric @go(Influxdb,*InfluxdbMetric) @protobuf(10,bytes,opt)

	// SkyWalking specifies the skywalking metric to query
	skywalking?: null | #SkyWalkingMetric @go(SkyWalking,*SkyWalkingMetric) @protobuf(11,bytes,opt)

	// +kubebuilder:validation:Schemaless
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Type=object
	// Plugin specifies the hashicorp go-plugin metric to query
	plugin?: {...} @go(Plugin,map[string]json.RawMessage) @protobuf(12,bytes,opt)
}

// AnalysisPhase is the overall phase of an AnalysisRun, MetricResult, or Measurement
#AnalysisPhase: string // #enumAnalysisPhase

#enumAnalysisPhase:
	#AnalysisPhasePending |
	#AnalysisPhaseRunning |
	#AnalysisPhaseSuccessful |
	#AnalysisPhaseFailed |
	#AnalysisPhaseError |
	#AnalysisPhaseInconclusive

#AnalysisPhasePending:      #AnalysisPhase & "Pending"
#AnalysisPhaseRunning:      #AnalysisPhase & "Running"
#AnalysisPhaseSuccessful:   #AnalysisPhase & "Successful"
#AnalysisPhaseFailed:       #AnalysisPhase & "Failed"
#AnalysisPhaseError:        #AnalysisPhase & "Error"
#AnalysisPhaseInconclusive: #AnalysisPhase & "Inconclusive"

// Arguments to perform a prometheus range query
#PrometheusRangeQueryArgs: {
	// The start time to query in expr format e.g. now(), now() - duration("1h"), now() - duration("{{args.lookback_duration}}")
	start?: string @go(Start) @protobuf(1,bytes,opt)

	// The end time to query in expr format e.g. now(), now() - duration("1h"), now() - duration("{{args.lookback_duration}}")
	end?: string @go(End) @protobuf(2,bytes,opt)

	// The maximum time between two slices from the start to end (e.g. 30s, 5m, 1h).
	step?: #DurationString @go(Step) @protobuf(3,bytes,opt,casttype=DurationString)
}

// PrometheusMetric defines the prometheus query to perform canary analysis
#PrometheusMetric: {
	// Address is the HTTP address and port of the prometheus server
	address?: string @go(Address) @protobuf(1,bytes,opt)

	// Query is a raw prometheus query to perform
	query?: string @go(Query) @protobuf(2,bytes,opt)

	// Authentication details
	// +optional
	authentication?: #Authentication @go(Authentication) @protobuf(3,bytes,opt)

	// Timeout represents the duration within which a prometheus query should complete. It is expressed in seconds.
	// +optional
	timeout?: null | int64 @go(Timeout,*int64) @protobuf(4,bytes,opt)

	// Insecure skips host TLS verification
	insecure?: bool @go(Insecure) @protobuf(5,varint,opt)

	// Headers are optional HTTP headers to use in the request
	// +optional
	// +patchMergeKey=key
	// +patchStrategy=merge
	headers?: [...#WebMetricHeader] @go(Headers,[]WebMetricHeader) @protobuf(6,bytes,opt)

	// Arguments for prometheus
	// +optional
	rangeQuery?: null | #PrometheusRangeQueryArgs @go(RangeQuery,*PrometheusRangeQueryArgs) @protobuf(7,bytes,opt)
}

// Authentication method
#Authentication: {
	// Sigv4 Config is the aws SigV4 configuration to use for SigV4 signing if using Amazon Managed Prometheus
	// +optional
	sigv4?: #Sigv4Config @go(Sigv4) @protobuf(1,bytes,opt)

	// OAuth2 config
	// +optional
	oauth2?: #OAuth2Config @go(OAuth2) @protobuf(2,bytes,opt)
}

#OAuth2Config: {
	// OAuth2 provider token URL
	tokenUrl?: string @go(TokenURL) @protobuf(1,bytes)

	// OAuth2 client ID
	clientId?: string @go(ClientID) @protobuf(2,bytes)

	// OAuth2 client secret
	clientSecret?: string @go(ClientSecret) @protobuf(3,bytes)

	// OAuth2 scopes
	// +optional
	scopes?: [...string] @go(Scopes,[]string) @protobuf(4,bytes,opt)
}

#Sigv4Config: {
	// Region is the AWS Region to sign the SigV4 Request
	region?: string @go(Region) @protobuf(1,bytes,opt,name=address)

	// Profile is the Credential Profile used to sign the SigV4 Request
	profile?: string @go(Profile) @protobuf(2,bytes,opt)

	// RoleARN is the IAM role used to sign the SIgV4 Request
	roleArn?: string @go(RoleARN) @protobuf(3,bytes,opt)
}

// WavefrontMetric defines the wavefront query to perform canary analysis
#WavefrontMetric: {
	// Address is the HTTP address and port of the wavefront server
	address?: string @go(Address) @protobuf(1,bytes,opt)

	// Query is a raw wavefront query to perform
	query?: string @go(Query) @protobuf(2,bytes,opt)
}

// NewRelicMetric defines the newrelic query to perform canary analysis
#NewRelicMetric: {
	// Profile is the name of the secret holding NR account configuration
	profile?: string @go(Profile) @protobuf(1,bytes,opt)

	// Query is a raw newrelic NRQL query to perform
	query: string @go(Query) @protobuf(2,bytes,opt)

	// Timeout represents the duration limit in seconds that will apply to the NRQL query
	// +optional
	timeout?: null | int64 @go(Timeout,*int64) @protobuf(3,bytes,opt)
}

// JobMetric defines a job to run which acts as a metric
#JobMetric: {
	metadata?: metav1.#ObjectMeta @go(Metadata) @protobuf(1,bytes,opt)
	spec:      batchv1.#JobSpec   @go(Spec) @protobuf(2,bytes,opt)
}

// GraphiteMetric defines the Graphite query to perform canary analysis
#GraphiteMetric: {
	// Address is the HTTP address and port of the Graphite server
	address?: string @go(Address) @protobuf(1,bytes,opt)

	// Query is a raw Graphite query to perform
	query?: string @go(Query) @protobuf(2,bytes,opt)
}

// InfluxdbMetric defines the InfluxDB Flux query to perform canary analysis
#InfluxdbMetric: {
	// Profile is the name of the secret holding InfluxDB account configuration
	profile?: string @go(Profile) @protobuf(1,bytes,opt)

	// Query is a raw InfluxDB flux query to perform
	query?: string @go(Query) @protobuf(2,bytes,opt)
}

// CloudWatchMetric defines the cloudwatch query to perform canary analysis
#CloudWatchMetric: {
	interval?: #DurationString @go(Interval) @protobuf(1,bytes,opt,casttype=DurationString)
	metricDataQueries: [...#CloudWatchMetricDataQuery] @go(MetricDataQueries,[]CloudWatchMetricDataQuery) @protobuf(2,bytes,rep)
}

// CloudWatchMetricDataQuery defines the cloudwatch query
#CloudWatchMetricDataQuery: {
	id?:         string                         @go(Id) @protobuf(1,bytes,opt)
	expression?: null | string                  @go(Expression,*string) @protobuf(2,bytes,opt)
	label?:      null | string                  @go(Label,*string) @protobuf(3,bytes,opt)
	metricStat?: null | #CloudWatchMetricStat   @go(MetricStat,*CloudWatchMetricStat) @protobuf(4,bytes,opt)
	period?:     null | intstrutil.#IntOrString @go(Period,*intstrutil.IntOrString) @protobuf(5,varint,opt)
	returnData?: null | bool                    @go(ReturnData,*bool) @protobuf(6,bytes,opt)
}

#CloudWatchMetricStat: {
	metric?: #CloudWatchMetricStatMetric @go(Metric) @protobuf(1,bytes,opt)
	period?: intstrutil.#IntOrString     @go(Period) @protobuf(2,varint,opt)
	stat?:   string                      @go(Stat) @protobuf(3,bytes,opt)
	unit?:   string                      @go(Unit) @protobuf(4,bytes,opt)
}

#CloudWatchMetricStatMetric: {
	dimensions?: [...#CloudWatchMetricStatMetricDimension] @go(Dimensions,[]CloudWatchMetricStatMetricDimension) @protobuf(1,bytes,rep)
	metricName?: string        @go(MetricName) @protobuf(2,bytes,opt)
	namespace?:  null | string @go(Namespace,*string) @protobuf(3,bytes,opt)
}

#CloudWatchMetricStatMetricDimension: {
	name?:  string @go(Name) @protobuf(1,bytes,opt)
	value?: string @go(Value) @protobuf(2,bytes,opt)
}

// AnalysisRun is an instantiation of an AnalysisTemplate
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=analysisruns, shortName=ar
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase",description="AnalysisRun status"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
#AnalysisRun: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)
	spec:      #AnalysisRunSpec   @go(Spec) @protobuf(2,bytes,opt)
	status?:   #AnalysisRunStatus @go(Status) @protobuf(3,bytes,opt)
}

// AnalysisRunList is a list of AnalysisTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#AnalysisRunList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items: [...#AnalysisRun] @go(Items,[]AnalysisRun) @protobuf(2,bytes,rep)
}

#SkyWalkingMetric: {
	address?:  string          @go(Address) @protobuf(1,bytes,opt)
	query?:    string          @go(Query) @protobuf(2,bytes,opt)
	interval?: #DurationString @go(Interval) @protobuf(3,bytes,opt,casttype=DurationString)
}

// AnalysisRunSpec is the spec for a AnalysisRun resource
#AnalysisRunSpec: {
	// Metrics contains the list of metrics to query as part of an analysis run
	// +patchMergeKey=name
	// +patchStrategy=merge
	metrics: [...#Metric] @go(Metrics,[]Metric) @protobuf(1,bytes,rep)

	// Args are the list of arguments used in this run
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	args?: [...#Argument] @go(Args,[]Argument) @protobuf(2,bytes,rep)

	// Terminate is used to prematurely stop the run (e.g. rollout completed and analysis is no longer desired)
	terminate?: bool @go(Terminate) @protobuf(3,varint,opt)

	// DryRun object contains the settings for running the analysis in Dry-Run mode
	// +patchMergeKey=metricName
	// +patchStrategy=merge
	// +optional
	dryRun?: [...#DryRun] @go(DryRun,[]DryRun) @protobuf(4,bytes,rep)

	// MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
	// +patchMergeKey=metricName
	// +patchStrategy=merge
	// +optional
	measurementRetention?: [...#MeasurementRetention] @go(MeasurementRetention,[]MeasurementRetention) @protobuf(5,bytes,rep)

	// TTLStrategy object contains the strategy for the time to live depending on if the analysis succeeded or failed
	// +optional
	ttlStrategy?: null | #TTLStrategy @go(TTLStrategy,*TTLStrategy) @protobuf(6,bytes,opt)
}

// Argument is an argument to an AnalysisRun
#Argument: {
	// Name is the name of the argument
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Value is the value of the argument
	// +optional
	value?: null | string @go(Value,*string) @protobuf(2,bytes,opt)

	// ValueFrom is a reference to where a secret is stored. This field is one of the fields with valueFrom
	// +optional
	valueFrom?: null | #ValueFrom @go(ValueFrom,*ValueFrom) @protobuf(3,bytes,opt)
}

#ValueFrom: {
	// Secret is a reference to where a secret is stored. This field is one of the fields with valueFrom
	// +optional
	secretKeyRef?: null | #SecretKeyRef @go(SecretKeyRef,*SecretKeyRef) @protobuf(1,bytes,opt)

	// FieldRef is a reference to the fields in metadata which we are referencing. This field is one of the fields with
	// valueFrom
	// +optional
	fieldRef?: null | #FieldRef @go(FieldRef,*FieldRef) @protobuf(2,bytes,opt)
}

#SecretKeyRef: {
	// Name is the name of the secret
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Key is the key of the secret to select from.
	key: string @go(Key) @protobuf(2,bytes,opt)
}

// AnalysisRunStatus is the status for a AnalysisRun resource
#AnalysisRunStatus: {
	// Phase is the status of the analysis run
	phase: #AnalysisPhase @go(Phase) @protobuf(1,bytes,opt,casttype=AnalysisPhase)

	// Message is a message explaining current status
	message?: string @go(Message) @protobuf(2,bytes,opt)

	// MetricResults contains the metrics collected during the run
	metricResults?: [...#MetricResult] @go(MetricResults,[]MetricResult) @protobuf(3,bytes,rep)

	// StartedAt indicates when the analysisRun first started
	startedAt?: null | metav1.#Time @go(StartedAt,*metav1.Time) @protobuf(4,bytes,opt)

	// RunSummary contains the final results from the metric executions
	runSummary?: #RunSummary @go(RunSummary) @protobuf(5,bytes,opt)

	// DryRunSummary contains the final results from the metric executions in the dry-run mode
	dryRunSummary?: null | #RunSummary @go(DryRunSummary,*RunSummary) @protobuf(6,bytes,opt)

	// CompletedAt indicates when the analysisRun completed
	completedAt?: null | metav1.#Time @go(CompletedAt,*metav1.Time) @protobuf(7,bytes,opt)
}

// RunSummary contains the final results from the metric executions
#RunSummary: {
	// This is equal to the sum of Successful, Failed, Inconclusive
	count?: int32 @go(Count) @protobuf(1,varint,opt)

	// Successful is the number of times the metric was measured Successful
	successful?: int32 @go(Successful) @protobuf(2,varint,opt)

	// Failed is the number of times the metric was measured Failed
	failed?: int32 @go(Failed) @protobuf(3,varint,opt)

	// Inconclusive is the number of times the metric was measured Inconclusive
	inconclusive?: int32 @go(Inconclusive) @protobuf(4,varint,opt)

	// Error is the number of times an error was encountered during measurement
	error?: int32 @go(Error) @protobuf(5,varint,opt)
}

// MetricResult contain a list of the most recent measurements for a single metric along with
// counters on how often the measurement
#MetricResult: {
	// Name is the name of the metric
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Phase is the overall aggregate status of the metric
	phase: #AnalysisPhase @go(Phase) @protobuf(2,bytes,opt,casttype=AnalysisPhase)

	// Measurements holds the most recent measurements collected for the metric
	measurements?: [...#Measurement] @go(Measurements,[]Measurement) @protobuf(3,bytes,rep)

	// Message contains a message describing current condition (e.g. error messages)
	message?: string @go(Message) @protobuf(4,bytes,opt)

	// Count is the number of times the metric was measured without Error
	// This is equal to the sum of Successful, Failed, Inconclusive
	count?: int32 @go(Count) @protobuf(5,varint,opt)

	// Successful is the number of times the metric was measured Successful
	successful?: int32 @go(Successful) @protobuf(6,varint,opt)

	// Failed is the number of times the metric was measured Failed
	failed?: int32 @go(Failed) @protobuf(7,varint,opt)

	// Inconclusive is the number of times the metric was measured Inconclusive
	inconclusive?: int32 @go(Inconclusive) @protobuf(8,varint,opt)

	// Error is the number of times an error was encountered during measurement
	error?: int32 @go(Error) @protobuf(9,varint,opt)

	// ConsecutiveError is the number of times an error was encountered during measurement in succession
	// Resets to zero when non-errors are encountered
	consecutiveError?: int32 @go(ConsecutiveError) @protobuf(10,varint,opt)

	// DryRun indicates whether this metric is running in a dry-run mode or not
	dryRun?: bool @go(DryRun) @protobuf(11,varint,opt)

	// Metadata stores additional metadata about this metric. It is used by different providers to store
	// the final state which gets used while taking measurements. For example, Prometheus uses this field
	// to store the final resolved query after substituting the template arguments.
	metadata?: {[string]: string} @go(Metadata,map[string]string) @protobuf(12,bytes,rep)

	// ConsecutiveSuccess is the number of times a measurement was successful in succession
	// Resets to zero when failures, inconclusive measurements, or errors are encountered
	consecutiveSuccess?: int32 @go(ConsecutiveSuccess) @protobuf(13,varint,opt)
}

// Measurement is a point in time result value of a single metric, and the time it was measured
#Measurement: {
	// Phase is the status of this single measurement
	phase: #AnalysisPhase @go(Phase) @protobuf(1,bytes,opt,casttype=AnalysisPhase)

	// Message contains a message describing current condition (e.g. error messages)
	message?: string @go(Message) @protobuf(2,bytes,opt)

	// StartedAt is the timestamp in which this measurement started to be measured
	startedAt?: null | metav1.#Time @go(StartedAt,*metav1.Time) @protobuf(3,bytes,opt)

	// FinishedAt is the timestamp in which this measurement completed and value was collected
	finishedAt?: null | metav1.#Time @go(FinishedAt,*metav1.Time) @protobuf(4,bytes,opt)

	// Value is the measured value of the metric
	value?: string @go(Value) @protobuf(5,bytes,opt)

	// Metadata stores additional metadata about this metric result, used by the different providers
	// (e.g. kayenta run ID, job name)
	metadata?: {[string]: string} @go(Metadata,map[string]string) @protobuf(6,bytes,rep)

	// ResumeAt is the  timestamp when the analysisRun should try to resume the measurement
	resumeAt?: null | metav1.#Time @go(ResumeAt,*metav1.Time) @protobuf(7,bytes,opt)
}

#KayentaMetric: {
	address:                  string            @go(Address) @protobuf(1,bytes,opt)
	application:              string            @go(Application) @protobuf(2,bytes,opt)
	canaryConfigName:         string            @go(CanaryConfigName) @protobuf(3,bytes,opt)
	metricsAccountName:       string            @go(MetricsAccountName) @protobuf(4,bytes,opt)
	configurationAccountName: string            @go(ConfigurationAccountName) @protobuf(5,bytes,opt)
	storageAccountName:       string            @go(StorageAccountName) @protobuf(6,bytes,opt)
	threshold:                #KayentaThreshold @go(Threshold) @protobuf(7,bytes,opt)
	scopes: [...#KayentaScope] @go(Scopes,[]KayentaScope) @protobuf(8,bytes,rep)
}

#KayentaThreshold: {
	pass:     int64 @go(Pass) @protobuf(1,varint,opt)
	marginal: int64 @go(Marginal) @protobuf(2,varint,opt)
}

#KayentaScope: {
	name:            string       @go(Name) @protobuf(1,bytes,opt)
	controlScope:    #ScopeDetail @go(ControlScope) @protobuf(2,bytes,opt)
	experimentScope: #ScopeDetail @go(ExperimentScope) @protobuf(3,bytes,opt)
}

#ScopeDetail: {
	scope:  string @go(Scope) @protobuf(1,bytes,opt)
	region: string @go(Region) @protobuf(2,bytes,opt)
	step:   int64  @go(Step) @protobuf(3,varint,opt)
	start:  string @go(Start) @protobuf(4,bytes,opt)
	end:    string @go(End) @protobuf(5,bytes,opt)
}

#WebMetric: {
	// Method is the method of the web metric (empty defaults to GET)
	method?: #WebMetricMethod @go(Method) @protobuf(1,bytes,opt)

	// URL is the address of the web metric
	url: string @go(URL) @protobuf(2,bytes,opt)

	// +patchMergeKey=key
	// +patchStrategy=merge
	// Headers are optional HTTP headers to use in the request
	headers?: [...#WebMetricHeader] @go(Headers,[]WebMetricHeader) @protobuf(3,bytes,rep)

	// Body is the body of the web metric (must be POST/PUT)
	body?: string @go(Body) @protobuf(4,bytes,opt)

	// TimeoutSeconds is the timeout for the request in seconds (default: 10)
	timeoutSeconds?: int64 @go(TimeoutSeconds) @protobuf(5,varint,opt)

	// JSONPath is a JSON Path to use as the result variable (default: "{$}")
	jsonPath?: string @go(JSONPath) @protobuf(6,bytes,opt)

	// Insecure skips host TLS verification
	insecure?: bool @go(Insecure) @protobuf(7,varint,opt)

	// +kubebuilder:validation:Schemaless
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Type=object
	// JSONBody is the body of the web metric in a json format (method must be POST/PUT)
	jsonBody?: _ @go(JSONBody,json.RawMessage) @protobuf(8,bytes,opt,casttype=encoding/json.RawMessage)

	// Authentication details
	// +optional
	authentication?: #Authentication @go(Authentication) @protobuf(9,bytes,opt)
}

// WebMetricMethod is the available HTTP methods
#WebMetricMethod: string // #enumWebMetricMethod

#enumWebMetricMethod:
	#WebMetricMethodGet |
	#WebMetricMethodPost |
	#WebMetricMethodPut

#WebMetricMethodGet:  #WebMetricMethod & "GET"
#WebMetricMethodPost: #WebMetricMethod & "POST"
#WebMetricMethodPut:  #WebMetricMethod & "PUT"

#WebMetricHeader: {
	key:   string @go(Key) @protobuf(1,bytes,opt)
	value: string @go(Value) @protobuf(2,bytes,opt)
}

#DatadogMetric: {
	// +kubebuilder:default="5m"
	// Interval refers to the Interval time window in Datadog (default: 5m). Not to be confused with the polling rate for the metric.
	interval?: #DurationString @go(Interval) @protobuf(1,bytes,opt,casttype=DurationString)
	query?:    string          @go(Query) @protobuf(2,bytes,opt)

	// Queries is a map of query_name_as_key: query. You can then use query_name_as_key inside Formula.Used for v2
	// +kubebuilder:validation:Type=object
	queries?: {[string]: string} @go(Queries,map[string]string) @protobuf(3,bytes,opt)

	// Formula refers to the Formula made up of the queries. Only useful with Queries. Used for v2
	formula?: string @go(Formula) @protobuf(4,bytes,opt)

	// ApiVersion refers to the Datadog API version being used (default: v1). v1 will eventually be deprecated.
	// +kubebuilder:validation:Enum=v1;v2
	// +kubebuilder:default=v1
	apiVersion?: string @go(ApiVersion) @protobuf(5,bytes,opt)

	// +kubebuilder:validation:Enum=avg;min;max;sum;last;percentile;mean;l2norm;area
	// Aggregator is a type of aggregator to use for metrics-based queries (default: ""). Used for v2
	aggregator?: string @go(Aggregator) @protobuf(6,bytes,opt)

	// Secret refers to the name of the secret that should be used for an analysis and should exists in the namespace where the controller is.
	// +optional
	secretRef?: #SecretRef @go(SecretRef) @protobuf(7,bytes,opt)
}

#SecretRef: {
	// Name refers to the name of the secret that should be used to integrate with Datadog.
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Namespaced indicates whether the secret is in the namespace where rollouts it installed or in the namespace where the metric was found
	namespaced?: bool @go(Namespaced) @protobuf(2,varint,opt,namespaced=dryRun)
}
